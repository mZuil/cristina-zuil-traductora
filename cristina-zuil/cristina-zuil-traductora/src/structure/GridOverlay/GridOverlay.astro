---
import './GridOverlay.css';
---

<div id="grid-overlay" class="grid-overlay hidden"></div>

<script>
  // Grid overlay toggle component with keyboard shortcut
  // Press Cmd+Shift+G (Mac) or Ctrl+Shift+G (Windows) to toggle

  (function() {
    // Wait for DOM to be ready
    function init() {
      let isVisible = false;
      const overlay = document.getElementById('grid-overlay');
      
      if (!overlay) {
        console.warn('GridOverlay: overlay element not found');
        return;
      }

      // Calculate grid overlay for the entire viewport
      function updateGridOverlay() {
        const rootStyle = getComputedStyle(document.documentElement);
        const viewportWidth = window.innerWidth;
        
        // Get breakpoints from CSS variables (from design tokens)
        const smBreakpoint = parseFloat(rootStyle.getPropertyValue('--breakpoint-sm').trim()) || 640;
        const mdBreakpoint = parseFloat(rootStyle.getPropertyValue('--breakpoint-md').trim()) || 768;
        const lgBreakpoint = parseFloat(rootStyle.getPropertyValue('--breakpoint-lg').trim()) || 1024;
        
        // Get max width from CSS variables (from design tokens)
        const maxWidthStr = rootStyle.getPropertyValue('--container-max-width-lg').trim();
        const maxWidth = parseFloat(maxWidthStr) || 1440;
        
        // Determine columns based on viewport width
        let columns = parseInt(rootStyle.getPropertyValue('--grid-columns-sm').trim()) || 4;
        let gap = rootStyle.getPropertyValue('--grid-gap-sm').trim() || '1rem';
        let padding = rootStyle.getPropertyValue('--container-padding-sm').trim() || '1rem';
        
        if (viewportWidth >= lgBreakpoint) {
          columns = parseInt(rootStyle.getPropertyValue('--grid-columns-lg').trim()) || 12;
          gap = rootStyle.getPropertyValue('--grid-gap-lg').trim() || '2rem';
          padding = rootStyle.getPropertyValue('--container-padding-lg').trim() || '3rem';
        } else if (viewportWidth >= mdBreakpoint) {
          columns = parseInt(rootStyle.getPropertyValue('--grid-columns-md').trim()) || 8;
          gap = rootStyle.getPropertyValue('--grid-gap-md').trim() || '1.5rem';
          padding = rootStyle.getPropertyValue('--container-padding-md').trim() || '2rem';
        }
        
        // Convert rem to px
        function remToPx(remStr) {
          if (remStr.includes('rem')) {
            const remValue = parseFloat(remStr);
            return remValue * parseFloat(getComputedStyle(document.documentElement).fontSize);
          }
          return parseFloat(remStr);
        }
        
        const gapValue = remToPx(gap);
        const paddingValue = remToPx(padding);
        
        // Calculate container width (max from design tokens, centered if viewport is larger)
        let containerWidth = viewportWidth;
        let containerLeft = 0;
        
        if (viewportWidth >= lgBreakpoint) {
          // For large screens, use max-width from design tokens
          containerWidth = Math.min(viewportWidth, maxWidth);
          // Center the container if viewport is larger than max-width
          if (viewportWidth > maxWidth) {
            containerLeft = (viewportWidth - maxWidth) / 2;
          }
        }
        
        const totalGaps = (columns - 1) * gapValue;
        const availableWidth = containerWidth - (paddingValue * 2);
        const columnWidth = (availableWidth - totalGaps) / columns;
        
        // Create grid lines for the entire viewport
        let overlayHTML = '';
        
        // Add viewport-wide grid overlay (centered if needed)
        overlayHTML += `<div class="grid-viewport-overlay" style="left: ${containerLeft}px; width: ${containerWidth}px;">`;
        
        // Draw column lines and gaps
        for (let i = 0; i <= columns; i++) {
          // Calculate the left edge of each column line
          const lineLeft = containerLeft + paddingValue + (i * (columnWidth + gapValue));
          
          // Column line
          overlayHTML += `<div class="grid-line grid-line-viewport" style="left: ${lineLeft}px;"></div>`;
          
          // Column number (centered in each column, except for the last line)
          if (i < columns) {
            // Center of the column: line position + half column width
            const numberLeft = lineLeft + columnWidth / 2;
            overlayHTML += `<div class="grid-column-number" style="left: ${numberLeft}px; top: 10px;">${i + 1}</div>`;
          }
          
          // Gap visualization (between columns, not after the last one)
          if (i < columns && gapValue > 0) {
            const gapLeft = lineLeft + columnWidth;
            overlayHTML += `<div class="grid-gap" style="left: ${gapLeft}px; width: ${gapValue}px;"></div>`;
          }
        }
        
        overlayHTML += '</div>';
        
        // Also overlay any CustomContainer components if they exist
        const containers = document.querySelectorAll('.custom-container');
        
        if (containers.length > 0) {
          containers.forEach((container) => {
            const el = container;
            const rect = el.getBoundingClientRect();
            const style = window.getComputedStyle(el);
            
            // Get breakpoints from CSS variables (from design tokens)
            const smBreakpoint = parseFloat(rootStyle.getPropertyValue('--breakpoint-sm').trim()) || 640;
            const mdBreakpoint = parseFloat(rootStyle.getPropertyValue('--breakpoint-md').trim()) || 768;
            const lgBreakpoint = parseFloat(rootStyle.getPropertyValue('--breakpoint-lg').trim()) || 1024;
            
            let containerColumns = parseInt(rootStyle.getPropertyValue('--grid-columns-sm').trim()) || 4;
            if (rect.width >= lgBreakpoint) {
              containerColumns = parseInt(rootStyle.getPropertyValue('--grid-columns-lg').trim()) || 12;
            } else if (rect.width >= mdBreakpoint) {
              containerColumns = parseInt(rootStyle.getPropertyValue('--grid-columns-md').trim()) || 8;
            }
            
            const containerGap = style.gap || '0';
            // Get padding - use paddingLeft (should be same as paddingRight due to CSS)
            const containerPaddingStr = style.paddingLeft || style.padding || '0';
            
            // Convert rem to px for container padding
            function remToPxContainer(remStr) {
              if (remStr.includes('rem')) {
                const remValue = parseFloat(remStr);
                return remValue * parseFloat(getComputedStyle(document.documentElement).fontSize);
              }
              return parseFloat(remStr);
            }
            
            const containerGapValue = remToPxContainer(containerGap);
            const containerPaddingValue = remToPxContainer(containerPaddingStr);
            const containerTotalGaps = (containerColumns - 1) * containerGapValue;
            const containerAvailableWidth = rect.width - (containerPaddingValue * 2);
            const containerColumnWidth = (containerAvailableWidth - containerTotalGaps) / containerColumns;
            
            const containerId = `grid-container-${Math.random().toString(36).substr(2, 9)}`;
            overlayHTML += `<div class="grid-container-overlay" data-container-id="${containerId}" style="top: ${rect.top + window.scrollY}px; left: ${rect.left}px; width: ${rect.width}px; height: ${rect.height}px;">`;
            
            // Calculate starting position relative to container's left edge
            const containerStartX = rect.left;
            
            for (let i = 0; i <= containerColumns; i++) {
              // Calculate position relative to viewport, accounting for container's position
              const lineLeft = containerStartX + containerPaddingValue + (i * (containerColumnWidth + containerGapValue));
              overlayHTML += `<div class="grid-line grid-line-container" style="left: ${lineLeft}px;"></div>`;
              
              // Column number for containers (centered in each column)
              if (i < containerColumns) {
                const numberLeft = lineLeft + containerColumnWidth / 2;
                overlayHTML += `<div class="grid-column-number grid-column-number-container" style="left: ${numberLeft}px; top: ${rect.top + window.scrollY + 10}px;">${i + 1}</div>`;
              }
              
              // Gap visualization
              if (i < containerColumns && containerGapValue > 0) {
                const gapLeft = lineLeft + containerColumnWidth;
                overlayHTML += `<div class="grid-gap grid-gap-container" style="left: ${gapLeft}px; width: ${containerGapValue}px; top: ${rect.top + window.scrollY}px; height: ${rect.height}px;"></div>`;
              }
            }
            
            overlayHTML += '</div>';
          });
        }
        
        overlay.innerHTML = overlayHTML;
      }

      function toggleGrid() {
        isVisible = !isVisible;
        overlay.classList.toggle('hidden', !isVisible);
        
        console.log('Grid overlay toggled:', isVisible ? 'ON' : 'OFF');
        
        if (isVisible) {
          updateGridOverlay();
          const updateHandler = () => {
            requestAnimationFrame(updateGridOverlay);
          };
          window.addEventListener('resize', updateHandler);
          window.addEventListener('scroll', updateHandler, true);
          
          // Store handlers for cleanup
          overlay._resizeHandler = updateHandler;
          overlay._scrollHandler = updateHandler;
        } else {
          const resizeHandler = overlay._resizeHandler;
          const scrollHandler = overlay._scrollHandler;
          if (resizeHandler) window.removeEventListener('resize', resizeHandler);
          if (scrollHandler) window.removeEventListener('scroll', scrollHandler, true);
        }
      }

      // Keyboard shortcut: Cmd+Shift+G (Mac) or Ctrl+Shift+G (Windows)
      document.addEventListener('keydown', (e) => {
        const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0 || 
                      navigator.userAgent.toUpperCase().indexOf('MAC') >= 0;
        const modifier = isMac ? e.metaKey : e.ctrlKey;
        
        if (modifier && e.shiftKey && (e.key === 'G' || e.key === 'g')) {
          e.preventDefault();
          e.stopPropagation();
          toggleGrid();
        }
      });
      
      console.log('GridOverlay initialized. Press Ctrl+Shift+G (Windows) or Cmd+Shift+G (Mac) to toggle.');
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  })();
</script>
